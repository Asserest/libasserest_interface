import 'dart:collection';

import 'package:meta/meta.dart';

import 'exceptions.dart';
import 'tester.dart' show AsserestTestPlatform;

/// A property interface for prepare assertion to tester.
///
/// Each [AsserestTestPlatform] only accept it's corresponsed
/// [AsserestProperty] based on [Uri.scheme].
///
/// It must be generated by [AsserestPropertyParser.parse] only
/// to ensure it can be identified by [runtimeType] when
/// constructing tester.
@immutable
abstract interface class AsserestProperty {
  const AsserestProperty._();

  /// The testing [url].
  Uri get url;

  /// Define [Duration] that [url] must be established entire connection
  /// in this windows. Otherwise, it counts as inaccessible.
  ///
  /// The default value is 10 seconds.
  Duration get timeout;

  /// Determine it is accessible before [timeout].
  bool get accessible;

  /// Count of retrying connection.
  ///
  /// This property only allowed to assign when [url] is [accessible].
  /// If the given value is [Null], it applied `1` as default value for
  /// [url] which expected to be [accessible].
  ///
  /// For applying non-`null` value to inaccessible [url], [StateError]
  /// should be thrown when constructing property.
  int? get tryCount;
}

/// Exception for creating property with undefined [scheme]
/// found in [AsserestPropertyParser].
///
/// To avoid this exception thrown, it is recommanded to verify
/// the related [PropertyParseProcessor] is defined already by
/// using [AsserestPropertyParser.isDefined].
final class UndefinedSchemeParserException extends AsserestException {
  /// An [Uri.scheme] which does not defined it's [PropertyParseProcessor].
  final String scheme;

  UndefinedSchemeParserException._(this.scheme)
      : super("The applied scheme is undefined");

  @override
  String toString() {
    StringBuffer buf = StringBuffer(super.toString())
      ..writeln("Applied scheme: $scheme");

    return buf.toString();
  }
}

/// A processor for constructing [T] which is corresponded child
/// class of [AsserestProperty].
abstract base class PropertyParseProcessor<T extends AsserestProperty> {
  /// Property parser, this must be remain nothing and should be able to
  /// construct as constant form.
  const PropertyParseProcessor();

  /// A [Set] of [String] that contains all supported URL schemes for this
  /// processor.
  @protected
  Set<String> get supportedSchemes;

  /// Define the construction of [AsserestProperty] with given [url], [timeout],
  /// [accessible] and [tryCount] with [additionalProperty] for those
  /// non-standard properties found in [Map].
  @protected
  T createProperty(Uri url, Duration timeout, bool accessible, int? tryCount,
      UnmodifiableMapView<String, dynamic> additionalProperty);

  /// Parse [T] by given [propertyMap].
  ///
  /// This method **is not** designed for inhertance since it defines all
  /// standardized properties in [Map] and convert to all builtin Dart object
  /// to [createProperty].
  ///
  /// If the property is incompleted, [InvalidPropertyMapException] will be thrown.
  ///
  /// If the parser does not support url scheme, [StateError] will be thrown.
  @protected
  @mustCallSuper
  T parse(Map<String, dynamic> propertyMap) {
    late final Uri url;
    late final bool accessible;

    try {
      url = Uri.parse(propertyMap["url"]);
      accessible = propertyMap["accessible"];
    } on TypeError {
      throw InvalidPropertyMapException._(propertyMap);
    }

    final Duration timeout = Duration(seconds: propertyMap["timeout"] ?? 10);
    final int? tryCount = propertyMap["try_count"];

    if (!supportedSchemes
        .any((element) => element.toLowerCase() == url.scheme)) {
      throw StateError(
          "URL scheme '${url.scheme}' is not handled by this processor.");
    } else if ((tryCount == null) ^ accessible) {
      throw InvalidPropertyMapException._(propertyMap);
    }

    return createProperty(
        url,
        timeout,
        accessible,
        tryCount,
        UnmodifiableMapView(Map.fromEntries(propertyMap.entries.where(
            (element) => !{"url", "timeout", "accessible", "try_count"}
                .contains(element)))));
  }
}

extension on PropertyParseProcessor {
  /// Convert all [supportedSchemes] to lower case.
  Set<String> get _allLowerSchemes =>
      supportedSchemes.map((e) => e.toLowerCase()).toSet();
}

/// A parser for parsing [Map] data to [AsserestProperty].
final class AsserestPropertyParser {
  /// Instance of this parser.
  static final AsserestPropertyParser _instance = AsserestPropertyParser._();

  final Map<String, PropertyParseProcessor> _parseProcessors = HashMap();

  AsserestPropertyParser._();

  /// Call the current instance of [AsserestPropertyParser].
  factory AsserestPropertyParser() => _instance;

  /// Determine the given [scheme] is defined already.
  bool isDefined(String scheme) => _parseProcessors.containsKey(scheme);

  /// Define a new [PropertyParseProcessor].
  ///
  /// It uses [PropertyParseProcessor.supportedSchemes] to determine the corresponsed
  /// scheme is handled by single parser in ideal case or replace to the new
  /// [processor] if [replaceIfDefined] enabled.
  void define(PropertyParseProcessor processor,
      {bool replaceIfDefined = false}) {
    for (String scheme in processor._allLowerSchemes) {
      if (!isDefined(scheme) || replaceIfDefined) {
        _parseProcessors[scheme] = processor;
      }
    }
  }

  /// Remove defined processor(s) with given [scheme].
  ///
  /// [scheme] can be either [Set] of [String] or just a [String].
  void removeDefined(Object scheme) {
    if (scheme is Set) {
      scheme.forEach(_parseProcessors.remove);
    } else if (scheme is String) {
      _parseProcessors.remove(scheme);
    } else {
      throw ArgumentError.value(
          scheme, "scheme", "The scheme should be either Set or String");
    }
  }

  /// Reset all mapped processors.
  void reset() {
    _parseProcessors.clear();
  }

  /// Parse [propertyMap] to corresponsed [AsserestProperty].
  ///
  /// If there is no `url` contains in [propertyMap], it throws
  /// [InvalidPropertyMapException]. When the given `url` is not
  /// URL string, [FormatException] will be thrown.
  ///
  /// If the given URL does not defined yet, it throws
  /// [UndefinedSchemeParserException].
  AsserestProperty parse(Map<String, dynamic> propertyMap) {
    late String scheme;

    try {
      scheme = Uri.parse(propertyMap["url"]).scheme;
    } on TypeError {
      throw InvalidPropertyMapException._(propertyMap);
    }

    try {
      return _parseProcessors[scheme]!.parse(propertyMap);
    } on TypeError {
      throw UndefinedSchemeParserException._(scheme);
    }
  }

  /// [parse] multiple [propertyMaps] into a single [List].
  List<AsserestProperty> parseList(List<Map<String, dynamic>> propertyMaps) {
    List<AsserestProperty> property = [];

    for (Map<String, dynamic> pmap in propertyMaps) {
      property.add(parse(pmap));
    }

    return UnmodifiableListView(property);
  }
}

/// An [Exception] when given property [Map] does not stastified
/// the standard.
final class InvalidPropertyMapException extends AsserestException {
  final Map<String, dynamic> _propertyMap;

  InvalidPropertyMapException._(this._propertyMap);

  @override
  String get message =>
      "The given property map does not stastified Asserest standard";

  @override
  String toString() {
    StringBuffer buf = StringBuffer("InvalidPropertyMapException: ")
      ..write(message)
      ..writeln("Applied property: ")
      ..write(_propertyMap);

    return buf.toString();
  }
}
