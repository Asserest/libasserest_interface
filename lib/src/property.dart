import 'dart:collection';

import 'package:meta/meta.dart';

import 'exceptions.dart';
import 'tester.dart' show AsserestTestPlatform;

/// A property interface for prepare assertion to tester.
///
/// Each [AsserestTestPlatform] only accept it's corresponsed
/// [AsserestProperty] based on [Uri.scheme].
///
/// It must be generated by [AsserestPropertyParser.parse] only
/// to ensure it can be identified by [runtimeType] when
/// constructing tester.
@immutable
abstract class AsserestProperty {
  const AsserestProperty._();

  /// The testing [url].
  Uri get url;

  /// Define [Duration] that [url] must be established entire connection
  /// in this windows. Otherwise, it counts as inaccessible.
  ///
  /// The default value is 10 seconds.
  Duration get timeout;

  /// Determine it is accessible before [timeout].
  bool get accessible;

  /// Count of retrying connection.
  ///
  /// This property only allowed to assign when [url] is [accessible].
  /// If the given value is [Null], it applied `1` as default value for
  /// [url] which expected to be [accessible].
  ///
  /// For applying non-`null` value to inaccessible [url], [StateError]
  /// should be thrown when constructing property.
  int? get tryCount;
}

/// Exception for creating property with undefined [scheme]
/// found in [AsserestPropertyParser].
///
/// To avoid this exception thrown, it is recommanded to verify
/// the related [PropertyParseProcessor] is defined already by
/// using [AsserestPropertyParser.isDefined].
class UndefinedSchemeParserException extends AsserestException {
  /// An [Uri.scheme] which does not defined it's [PropertyParseProcessor].
  final String scheme;

  UndefinedSchemeParserException._(this.scheme)
      : super("The applied scheme is undefined");

  @override
  String toString() {
    StringBuffer buf = StringBuffer(super.toString())
      ..writeln("Applied scheme: $scheme");

    return buf.toString();
  }
}

/// A processor for constructing [T] which is corresponded child
/// class of [AsserestProperty].
abstract class PropertyParseProcessor<T extends AsserestProperty> {
  /// Property parser, this must be remain nothing and should be able to
  /// construct as constant form.
  const PropertyParseProcessor();

  /// A pattern of [RegExp] uses for matching URL scheme which disable case
  /// sensitive and dot all with unicode supported.
  @protected
  String get schemeRegex;

  /// Define the construction of [AsserestProperty] with given [url], [timeout],
  /// [accessible] and [tryCount] with [additionalProperty] for those
  /// non-standard properties found in [Map].
  @protected
  T createProperty(Uri url, Duration timeout, bool accessible, int? tryCount,
      UnmodifiableMapView<String, dynamic> additionalProperty);

  /// Parse [T] by given [propertyMap].
  ///
  /// This method **is not** designed for inhertance since it defines all
  /// standardized properties in [Map] and convert to all builtin Dart object
  /// to [createProperty].
  @protected
  @mustCallSuper
  T parse(Map<String, dynamic> propertyMap) {
    final Uri url = Uri.parse(propertyMap["url"]);
    final Duration timeout = Duration(seconds: propertyMap["timeout"] ?? 10);
    final bool accessible = propertyMap["accessible"];
    final int? tryCount = propertyMap["try_count"];

    if (!RegExp(schemeRegex, caseSensitive: false, dotAll: false, unicode: true)
        .hasMatch(url.scheme)) {
      throw StateError(
          "URL scheme '${url.scheme}' is not handled by this processor.");
    } else if ((tryCount == null) ^ accessible) {
      throw ArgumentError.value(tryCount, "try_count",
          "Try count is required only if the URL is accessible.");
    }

    return createProperty(
        url,
        timeout,
        accessible,
        tryCount,
        UnmodifiableMapView(Map.fromEntries(propertyMap.entries.where(
            (element) => !{"url", "timeout", "accessible", "try_count"}
                .contains(element)))));
  }
}

/// A parser for parsing [Map] data to [AsserestProperty].
@sealed
class AsserestPropertyParser {
  /// Instance of this parser.
  static final AsserestPropertyParser _instance = AsserestPropertyParser._();

  /// A [Set] of [PropertyParseProcessor] which using [PropertyParseProcessor.schemeRegex]'s
  /// hashcode to identify.
  final Set<PropertyParseProcessor> _parseProcessors = HashSet(
      equals: (p0, p1) => p0.schemeRegex == p1.schemeRegex,
      hashCode: (processor) => processor.schemeRegex.hashCode);

  AsserestPropertyParser._();

  /// Call the current instance of [AsserestPropertyParser].
  factory AsserestPropertyParser() => _instance;

  /// Determine the given [scheme] is defined already.
  bool isDefined(String scheme) => _parseProcessors
      .any((element) => RegExp(element.schemeRegex).hasMatch(scheme));

  /// Define a new [PropertyParseProcessor].
  /// 
  /// It uses [PropertyParseProcessor.schemeRegex] to determine the corresponsed
  /// scheme is handled by single parser in ideal case or replace to the new
  /// [processor] if [replaceIfDefined] enabled
  /// 
  /// It's expected there is no duplicated pattern for identifying the same schemes
  /// wihch it uses the first processor in [HashSet].
  void define(PropertyParseProcessor processor,
      {bool replaceIfDefined = false}) {
    if (_parseProcessors.contains(processor) && replaceIfDefined) {
      _parseProcessors.remove(processor);
    }

    _parseProcessors.add(processor);
  }

  void reset() {
    _parseProcessors.clear();
  }

  AsserestProperty parse(Map<String, dynamic> propertyMap) {
    return _parseProcessors
        .where((element) => RegExp(element.schemeRegex,
                caseSensitive: false, dotAll: false, unicode: true)
            .hasMatch(propertyMap["url"]))
        .first
        .parse(propertyMap);
  }

  List<AsserestProperty> parseList(List<Map<String, dynamic>> propertyMaps) =>
      List.generate(propertyMaps.length, (index) => parse(propertyMaps[index]),
          growable: false);
}
